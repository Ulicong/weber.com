{
  "name": "李欢的个人空间",
  "tagline": "LiHuan's Personal Space",
  "body": "### 先来个自我评价吧.\r\n首先对于工作、我热爱她愿意为她付出；其次对于沟通协调方面我想没有问题；我愿意分享、喜欢分享我对技术方面的理解和感悟；曾经多次在公司内部分享交流过数据库、多线程方面的知识；对于技术我喜欢开源、喜欢刨根问底；曾手动编译过JVM、阅读过JVM源码及其规范；对于通信、大数据、分布式、Js都有深入的学习心得；最后对于编程思想方面、思想和眼界我感觉很重要；我的座右铭是“要用CPU的思维来编程!”。\r\n\r\n### Java锁\r\n#### 总结\r\n1. synchronized同步锁是作用在对象上面对象必需统一不能变；\r\n2. 线程同步互斥指的是多个线程执行同一段代码或执行多段代码而不被打断；\r\n3. 注意synchronized作用于XX.class子节码时的同步互斥情况；\r\n4. synchronized同步块可以作用于String变量上但不能作用于char、int、double等java基本类型上因为它们定义时不会生成对象；\r\n5. Lock实现同步互斥时必需共用同一个ReentrantLock对象；注意添加finally释放锁;\r\n6. Synchronized的语义底层是通过一个monitor的对象来完成，其实wait/notify等方法也依赖于monitor对象，这就是为什么只有在同步的块或者方法中才能调用wait/notify等方法，否则会抛出      java.lang.IllegalMonitorStateException的异常的原因。\r\n\r\n#### synchronized原理\r\n每个对象有一个监视器锁（monitor）。当monitor被占用时就会处于锁定状态，线程执行monitorenter指令时尝试获取monitor的所有权，过程如下：\r\n1. 如果monitor的进入数为0，则该线程进入monitor，然后将进入数设置为1，该线程即为monitor的所有者。\r\n2. 如果线程已经占有该monitor，只是重新进入，则进入monitor的进入数加1.\r\n3. 如果其他线程已经占用了monitor，则该线程进入阻塞状态，直到monitor的进入数为0，再重新尝试获取monitor的所有权。\r\n4. 执行monitorexit的线程必须是objectref所对应的monitor的所有者。\r\n5. 指令执行时，monitor的进入数减1，如果减1后进入数为0，那线程退出monitor，不再是这个monitor的所有者。其他被这个monitor阻塞的线程可以尝试去获取这个 monitor 的所有权。\r\n\r\n#### Lock\r\nLock比传统线程模型中的synchronized方式更加面向对象，与生活中的锁类似，锁本身也应该是一个对象。两个线程执行的代码片段要实现同步互斥的效果，它们必须用同一个Lock对象。\r\n\r\n####  读写锁\r\n读写锁：分为读锁和写锁，多个读锁不互斥，读锁与写锁互斥，这是由jvm自己控制的，你只要上好相应的锁即可。如果你的代码只读数据，可以很多人同时读，但不能同时写，那就上读锁；如果你的代码修改数据，只能有一个人在写，且不能同时读取，那就上写锁。总之，读的时候上读锁，写的时候上写锁！\r\n```\r\n/**\r\n\t * 读写锁 启动6个线程分别对data变量进行读写操作\r\n\t */\r\n\tpublic static void main(String[] args) {\r\n\t\tfinal Quen3 quen3 = new Quen3();\r\n\t\tfor (int i = 0; i < 3; i++) {\r\n\r\n\t\t\tnew Thread(new Runnable() {\r\n\r\n\t\t\t\t@Override\r\n\t\t\t\tpublic void run() {\r\n\t\t\t\t\tquen3.get();\r\n\t\t\t\t}\r\n\t\t\t}).start();\r\n\r\n\t\t\tnew Thread(new Runnable() {\r\n\r\n\t\t\t\t@Override\r\n\t\t\t\tpublic void run() {\r\n\t\t\t\t\tquen3.set(new Random().nextInt(10000));\r\n\t\t\t\t}\r\n\t\t\t}).start();\r\n\t\t}\r\n\r\n\t}\r\n\r\n}\r\n\r\nclass Quen3 {\r\n\tprivate int data;\r\n\tReentrantReadWriteLock rwl = new ReentrantReadWriteLock();//加上读写锁\r\n\r\n\tpublic void get() {\r\n\t\trwl.readLock().lock();\r\n\t\ttry {\r\n\t\t\tSystem.out.println(Thread.currentThread().getName()\r\n\t\t\t\t\t+ \" is Ready to read data!\");\r\n\t\t\tThread.sleep(1000);\r\n\t\t\tSystem.out.println(Thread.currentThread().getName()\r\n\t\t\t\t\t+ \" have read data \" + data);\r\n\t\t} catch (Exception e) {\r\n\t\t\te.printStackTrace();\r\n\t\t} finally {\r\n\t\t\trwl.readLock().unlock();//注意关闭锁\r\n\t\t}\r\n\t}\r\n\r\n\tpublic void set(int data) {\r\n\t\trwl.writeLock().lock();\r\n\t\ttry {\r\n\t\t\tthis.data = data;\r\n\t\t\tSystem.out.println(Thread.currentThread().getName()\r\n\t\t\t\t\t+ \" is Ready to set data!\");\r\n\t\t\tThread.sleep(1000);\r\n\t\t\tSystem.out.println(Thread.currentThread().getName() + \" have set \"\r\n\t\t\t\t\t+ data);\r\n\t\t} catch (Exception e) {\r\n\t\t\te.printStackTrace();\r\n\t\t} finally {\r\n\t\t\trwl.writeLock().unlock();\r\n\t\t}\r\n\t}\r\n\r\n```",
  "note": "Don't delete this file! It's used internally to help with page regeneration."
}